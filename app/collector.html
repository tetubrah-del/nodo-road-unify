<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Nodo Collector</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    body, html { margin:0; padding:0; height:100%; }
    body { display:flex; flex-direction:column; background:#f5f5f5; }
    #map { height:calc(50vh); min-height:45vh; width:100%; }
    #controls {
      padding:16px;
      background:#f5f5f5;
      display:flex;
      flex-direction:column;
      gap:12px;
      box-sizing:border-box;
      max-width:480px;
      width:100%;
      margin:0 auto;
      flex:1;
    }
    .button-row {
      display:flex;
      flex-direction:column;
      gap:8px;
      width:100%;
      margin-top:8px;
    }
    .big-btn {
      padding:16px 20px;
      font-size:18px;
      width:100%;
      border-radius:10px;
      min-height:56px;
      border:1px solid #ccc;
      background:#fff;
      cursor:pointer;
    }
    #status { font-weight:bold; color:#333; font-size:16px; margin-top:4px; }
    #points-count { font-size:15px; color:#555; }
    #error { font-size:14px; color:#c62828; margin-top:4px; }
    .toggle-row {
      display:flex;
      align-items:center;
      gap:12px;
      font-size:16px;
      min-height:44px;
      padding:4px 0;
    }
    .toggle-row .sensor-checkbox {
      transform: scale(1.4);
      margin-right:8px;
    }
    .toggle-row span { font-size:14px; color:#555; }
    #sensor-status { font-size:14px; color:#555; }
    .note-label { font-size:13px; color:#555; display:flex; flex-direction:column; gap:4px; }
    textarea#note { width:100%; font-size:14px; padding:8px; box-sizing:border-box; }
    @media (max-width: 420px) {
      .big-btn { width:100%; }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <div class="button-row">
      <button id="startBtn" class="big-btn">記録開始</button>
      <button id="stopSendBtn" class="big-btn" disabled>記録停止＆送信</button>
    </div>
    <div id="points-count">記録ポイント数: 0</div>
    <div id="status">待機中</div>
    <label class="toggle-row">
      <input type="checkbox" id="sensorToggle" class="sensor-checkbox" />
      車両固定モード（センサー ON/OFF）
      <span id="sensor-mode-label"></span>
    </label>
    <div id="sensor-status"></div>
    <label class="note-label">
      メモ (任意)
      <textarea id="note" rows="2"></textarea>
    </label>
    <div id="error"></div>
    <div id="collector-last-result" style="margin-top: 8px; font-size: 0.9rem;"></div>
    <div style="font-size:12px; color:#777;">ブラウザの位置情報を許可してから記録してください。</div>
    <hr />
    <h3 style="font-size: 1rem; margin-top: 8px;">直近の記録一覧（デバッグ用）</h3>
    <button id="refresh-recent-runs" type="button">一覧を更新</button>
    <div id="recent-runs-status" style="margin-top: 4px; font-size: 0.8rem;"></div>
    <table id="recent-runs-table" style="width: 100%; font-size: 0.8rem; margin-top: 4px; border-collapse: collapse;">
      <thead>
        <tr>
          <th style="border-bottom: 1px solid #ccc;">link_id</th>
          <th style="border-bottom: 1px solid #ccc;">危険度</th>
          <th style="border-bottom: 1px solid #ccc;">距離[m]</th>
          <th style="border-bottom: 1px solid #ccc;">スナップ</th>
          <th style="border-bottom: 1px solid #ccc;">距離差[m]</th>
          <th style="border-bottom: 1px solid #ccc;">モード</th>
          <th style="border-bottom: 1px solid #ccc;">点数</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    const map = L.map("map").setView([33.1471, 131.5218], 16);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18,
    }).addTo(map);

    let watchId = null;
    let recordedPoints = [];
    let polyline = null;

    const startBtn = document.getElementById("startBtn");
    const stopSendBtn  = document.getElementById("stopSendBtn");
    const statusEl = document.getElementById("status");
    const pointsCountEl = document.getElementById("points-count");
    const noteEl = document.getElementById("note");
    const errorEl = document.getElementById("error");
    const sensorToggle = document.getElementById("sensorToggle");
    const sensorStatusEl = document.getElementById("sensor-status");
    const sensorModeLabelEl = document.getElementById("sensor-mode-label");
    const lastResultEl = document.getElementById("collector-last-result");
    const recentRunsBtn = document.getElementById("refresh-recent-runs");
    const recentRunsStatusEl = document.getElementById("recent-runs-status");
    const recentRunsTableBody = document.querySelector("#recent-runs-table tbody");

    function createSensorTracker() {
      let enabled = false;
      let sessionActive = false;
      let listenersAttached = false;
      let sumSquares = 0;
      let maxAbs = 0;
      let sampleCount = 0;
      let pitchSum = 0;
      let pitchCount = 0;
      let lastPitchDeg = null;

      const resetStats = () => {
        sumSquares = 0;
        maxAbs = 0;
        sampleCount = 0;
        pitchSum = 0;
        pitchCount = 0;
      };

      const handleOrientation = (event) => {
        if (typeof event.beta === 'number') {
          lastPitchDeg = event.beta;
        }
      };

      const handleMotion = (event) => {
        if (!sessionActive) return;
        const acc = event.accelerationIncludingGravity || event.acceleration;
        if (!acc || typeof acc.z !== 'number') return;
        const vertical = acc.z;
        const absVal = Math.abs(vertical);
        sumSquares += vertical * vertical;
        sampleCount += 1;
        if (sampleCount === 1) {
          maxAbs = absVal;
        } else {
          maxAbs = Math.max(maxAbs, absVal);
        }

        if (typeof lastPitchDeg === 'number') {
          pitchSum += lastPitchDeg;
          pitchCount += 1;
        }
      };

      const attachListeners = () => {
        if (listenersAttached) return;
        window.addEventListener('devicemotion', handleMotion);
        window.addEventListener('deviceorientation', handleOrientation);
        listenersAttached = true;
        console.log('[sensor] listeners attached');
      };

      const detachListeners = () => {
        if (!listenersAttached) return;
        window.removeEventListener('devicemotion', handleMotion);
        window.removeEventListener('deviceorientation', handleOrientation);
        listenersAttached = false;
        console.log('[sensor] listeners detached');
      };

      const ensurePermission = async () => {
        if (typeof DeviceMotionEvent === 'undefined') {
          console.warn('[sensor] DeviceMotionEvent not available');
          return false;
        }

        // iOS Safari requires an explicit permission request
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
          try {
            const resp = await DeviceMotionEvent.requestPermission();
            return resp === 'granted';
          } catch (e) {
            console.warn('[sensor] permission request failed', e);
            return false;
          }
        }
        return true;
      };

      const enable = async () => {
        const permitted = await ensurePermission();
        enabled = permitted;
        if (enabled) {
          attachListeners();
        } else {
          detachListeners();
        }
        return enabled;
      };

      const disable = () => {
        enabled = false;
        detachListeners();
      };

      const startSession = () => {
        resetStats();
        sessionActive = true;
        if (enabled) {
          attachListeners();
        }
      };

      const stopSession = () => {
        sessionActive = false;
      };

      const getSummary = () => {
        if (!enabled) {
          return {
            mode: 'off',
            vertical_rms: null,
            vertical_max: null,
            pitch_mean_deg: null,
            sensor_samples: 0,
          };
        }

        const vertical_rms = sampleCount > 0 ? Math.sqrt(sumSquares / sampleCount) : null;
        const vertical_max = sampleCount > 0 ? maxAbs : null;
        const pitch_mean_deg = pitchCount > 0 ? pitchSum / pitchCount : null;

        return {
          mode: 'vehicle',
          vertical_rms,
          vertical_max,
          pitch_mean_deg,
          sensor_samples: sampleCount,
        };
      };

      return { enable, disable, startSession, stopSession, getSummary };
    }

    const sensorTracker = createSensorTracker();

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function setError(text) {
      errorEl.textContent = text || '';
    }

    function setLastResult(text) {
      lastResultEl.textContent = text || '';
    }

    function updateSensorModeLabel() {
      const on = sensorToggle.checked;
      sensorModeLabelEl.textContent = on ? 'モード: 車両センサーON' : 'モード: GPSのみ';
    }

    function updatePointsCount() {
      pointsCountEl.textContent = `記録ポイント数: ${recordedPoints.length}`;
    }

    function resetRecording() {
      recordedPoints = [];
      updatePointsCount();
      if (polyline) {
        map.removeLayer(polyline);
        polyline = null;
      }
    }

    function renderRecentRuns(rows) {
      recentRunsTableBody.innerHTML = '';
      rows.forEach((run) => {
        const tr = document.createElement('tr');

        const dangerText = typeof run.danger_score === 'number'
          ? run.danger_score.toFixed(1)
          : '-';
        const lengthText = typeof run.length_m === 'number'
          ? Math.round(run.length_m).toString()
          : '-';
        const snappingUsedText = run.snapping_used ? 'あり' : 'なし';
        const snappingDistText = typeof run.snapping_distance_m === 'number'
          ? run.snapping_distance_m.toFixed(1)
          : '–';
        const modeText = run.mode === 'vehicle' ? '車両センサーON' : 'GPSのみ';
        const pointsText = typeof run.num_points === 'number' ? run.num_points.toString() : '–';

        [
          run.link_id,
          dangerText,
          lengthText,
          snappingUsedText,
          snappingDistText,
          modeText,
          pointsText,
        ].forEach((val) => {
          const td = document.createElement('td');
          td.textContent = val ?? '-';
          td.style.borderBottom = '1px solid #eee';
          td.style.padding = '2px 4px';
          tr.appendChild(td);
        });

        recentRunsTableBody.appendChild(tr);
      });
    }

    async function loadRecentRuns(limit = 20) {
      recentRunsStatusEl.textContent = '読み込み中…';
      try {
        const res = await fetch(`/api/collector/recent?limit=${limit}`);
        const data = await res.json();
        if (!res.ok) {
          throw new Error('failed to load');
        }
        const runs = Array.isArray(data.runs) ? data.runs : [];
        renderRecentRuns(runs);
        recentRunsStatusEl.textContent = `直近 ${runs.length} 件を表示中`;
      } catch (e) {
        console.error(e);
        recentRunsStatusEl.textContent = '一覧の取得に失敗しました。';
      }
    }

    recentRunsBtn.addEventListener('click', () => {
      loadRecentRuns();
    });

    async function toggleSensors(checked) {
      if (checked) {
        const ok = await sensorTracker.enable();
        if (ok) {
          sensorStatusEl.textContent = 'センサー計測中 (車両固定モード)';
        } else {
          sensorToggle.checked = false;
          sensorStatusEl.textContent = 'センサー非対応、または許可が必要です';
        }
      } else {
        sensorTracker.disable();
        sensorStatusEl.textContent = 'センサーOFF（GPSのみ）';
      }
      updateSensorModeLabel();
    }

    sensorToggle.addEventListener('change', (e) => {
      toggleSensors(e.target.checked);
    });

    // Initialize sensor status on load
    sensorStatusEl.textContent = 'センサーOFF（GPSのみ）';
    updateSensorModeLabel();

    function haversineDistanceMeters(p1, p2) {
      const R = 6371000;
      const dLat = (p2.lat - p1.lat) * Math.PI / 180;
      const dLon = (p2.lon - p1.lon) * Math.PI / 180;
      const lat1 = p1.lat * Math.PI / 180;
      const lat2 = p2.lat * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function computeTrackLengthMeters(points) {
      if (!Array.isArray(points) || points.length < 2) return 0;
      let total = 0;
      for (let i = 0; i < points.length - 1; i++) {
        total += haversineDistanceMeters(points[i], points[i + 1]);
      }
      return Math.round(total);
    }

    startBtn.onclick = () => {
      resetRecording();
      statusEl.textContent = "GPS記録中...";
      startBtn.disabled = true;
      stopSendBtn.disabled = false;
      sensorTracker.startSession();

      if (!navigator.geolocation) {
        alert("この端末はGPSが使えません");
        setStatus("GPS非対応");
        startBtn.disabled = false;
        stopSendBtn.disabled = true;
        sensorTracker.stopSession();
        return;
      }

      watchId = navigator.geolocation.watchPosition(
        (pos) => {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          const point = { lat, lon, timestamp_ms: Date.now() };
          recordedPoints.push(point);
          updatePointsCount();

          if (!polyline) {
            polyline = L.polyline([[lat, lon]], { color: "blue" }).addTo(map);
          } else {
            polyline.addLatLng([lat, lon]);
          }
        },
        (err) => {
          console.error(err);
          alert("位置情報が取得できません: " + err.message);
        },
        {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 10000,
        }
      );
    };

    stopSendBtn.onclick = async () => {
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }

      sensorTracker.stopSession();

      if (recordedPoints.length < 2) {
        alert("2ポイント以上記録してから送信してください");
        setStatus("記録が少なすぎます");
        startBtn.disabled = false;
        stopSendBtn.disabled = true;
        return;
      }

      setStatus("送信中...");
      const currentPoints = recordedPoints.slice();
      try {
        setError('');
        const res = await fetch('/api/collector/submit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            points: recordedPoints,
            sensor_summary: sensorTracker.getSummary(),
            meta: { note: noteEl.value || undefined },
          }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.detail || '送信に失敗しました');
        }
        setStatus(`送信完了。link_id=${data.link_id}, danger_score=${data.danger_score}`);
        const snappedText = data.snapping_used ? 'あり' : 'なし';
        const distance = computeTrackLengthMeters(currentPoints);
        const modeText = sensorToggle.checked ? '車両センサーON' : 'GPSのみ';
        const dangerText = typeof data.danger_score === 'number' ? data.danger_score.toFixed(1) : '-';
        setLastResult(`直近の記録: link_id=${data.link_id}, 危険度=${dangerText}, 距離=${distance}m, スナップ=${snappedText}, モード=${modeText}`);
        loadRecentRuns();
        alert('送信しました');
        resetRecording();
      } catch (e) {
        console.error(e);
        setStatus("送信エラー");
        setError(e.message);
        setLastResult('記録の送信に失敗しました。ネットワークを確認してください。');
      }

      startBtn.disabled = false;
      stopSendBtn.disabled = true;
      sensorTracker.stopSession();
      loadRecentRuns();
    };
  </script>

  <!-- Self-review:
       - /api/collector/submit に GPS ポイントを送信し、road_links に source='gps' で LINESTRING を挿入し、meta から danger_score を付与するようにした。
       - collector.html にブラウザの geolocation API を使った Start/Stop ロガーと、API への送信処理を追加した。

       Testing:
       - ローカルで `uvicorn main:app --reload` を起動。
       - ブラウザで `http://localhost:8000/collector` を開き、屋外 or 擬似位置情報で「記録開始」→少し移動→「記録停止＆送信」を実行。
       - サーバのログで `/api/collector/submit` のリクエストが成功し、レスポンス JSON に `status: ok` と `danger_score` が含まれていることを確認。
       - `/map` を開き、GPS レイヤー（青）の中に、新しいログの LINESTRING が描画されていることを確認。
  -->
</body>
</html>
