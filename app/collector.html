<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Nodo Collector</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    body, html { margin:0; padding:0; height:100%; }
    #map { height:60%; }
    #controls { padding:12px; background:#f5f5f5; display:flex; flex-direction:column; gap:8px; }
    #status { font-weight:bold; color:#333; }
    #points-count { font-size:14px; color:#555; }
    .toggle-row { display:flex; align-items:center; gap:8px; font-size:14px; }
    .toggle-row input { transform: scale(1.2); }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button id="startBtn">記録開始</button>
      <button id="stopSendBtn" disabled>記録停止＆送信</button>
    </div>
    <div id="points-count">記録ポイント数: 0</div>
    <div id="status">待機中</div>
    <label class="toggle-row">
      <input type="checkbox" id="sensorToggle" />
      車両固定モード（センサー ON/OFF）
    </label>
    <div id="sensor-status" style="font-size:12px; color:#555;"></div>
    <label style="font-size:12px; color:#555; display:flex; flex-direction:column; gap:4px;">
      メモ (任意)
      <textarea id="note" rows="2" style="width:100%;"></textarea>
    </label>
    <div id="error" style="color:#b00020; font-size:13px;"></div>
    <div style="font-size:12px; color:#777;">ブラウザの位置情報を許可してから記録してください。</div>
  </div>

  <script>
    const map = L.map("map").setView([33.1471, 131.5218], 16);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18,
    }).addTo(map);

    let watchId = null;
    let recordedPoints = [];
    let polyline = null;

    const startBtn = document.getElementById("startBtn");
    const stopSendBtn  = document.getElementById("stopSendBtn");
    const statusEl = document.getElementById("status");
    const pointsCountEl = document.getElementById("points-count");
    const noteEl = document.getElementById("note");
    const errorEl = document.getElementById("error");
    const sensorToggle = document.getElementById("sensorToggle");
    const sensorStatusEl = document.getElementById("sensor-status");

    function createSensorTracker() {
      let enabled = false;
      let sessionActive = false;
      let listenersAttached = false;
      let sumSquares = 0;
      let maxAbs = 0;
      let sampleCount = 0;
      let pitchSum = 0;
      let pitchCount = 0;
      let lastPitchDeg = null;

      const resetStats = () => {
        sumSquares = 0;
        maxAbs = 0;
        sampleCount = 0;
        pitchSum = 0;
        pitchCount = 0;
      };

      const handleOrientation = (event) => {
        if (typeof event.beta === 'number') {
          lastPitchDeg = event.beta;
        }
      };

      const handleMotion = (event) => {
        if (!sessionActive) return;
        const acc = event.accelerationIncludingGravity || event.acceleration;
        if (!acc || typeof acc.z !== 'number') return;
        const vertical = acc.z;
        const absVal = Math.abs(vertical);
        sumSquares += vertical * vertical;
        sampleCount += 1;
        if (sampleCount === 1) {
          maxAbs = absVal;
        } else {
          maxAbs = Math.max(maxAbs, absVal);
        }

        if (typeof lastPitchDeg === 'number') {
          pitchSum += lastPitchDeg;
          pitchCount += 1;
        }
      };

      const attachListeners = () => {
        if (listenersAttached) return;
        window.addEventListener('devicemotion', handleMotion);
        window.addEventListener('deviceorientation', handleOrientation);
        listenersAttached = true;
        console.log('[sensor] listeners attached');
      };

      const detachListeners = () => {
        if (!listenersAttached) return;
        window.removeEventListener('devicemotion', handleMotion);
        window.removeEventListener('deviceorientation', handleOrientation);
        listenersAttached = false;
        console.log('[sensor] listeners detached');
      };

      const ensurePermission = async () => {
        if (typeof DeviceMotionEvent === 'undefined') {
          console.warn('[sensor] DeviceMotionEvent not available');
          return false;
        }

        // iOS Safari requires an explicit permission request
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
          try {
            const resp = await DeviceMotionEvent.requestPermission();
            return resp === 'granted';
          } catch (e) {
            console.warn('[sensor] permission request failed', e);
            return false;
          }
        }
        return true;
      };

      const enable = async () => {
        const permitted = await ensurePermission();
        enabled = permitted;
        if (enabled) {
          attachListeners();
        } else {
          detachListeners();
        }
        return enabled;
      };

      const disable = () => {
        enabled = false;
        detachListeners();
      };

      const startSession = () => {
        resetStats();
        sessionActive = true;
        if (enabled) {
          attachListeners();
        }
      };

      const stopSession = () => {
        sessionActive = false;
      };

      const getSummary = () => {
        if (sampleCount === 0) {
          return {
            mode: 'off',
            vertical_rms: null,
            vertical_max: null,
            pitch_mean_deg: null,
            sensor_samples: 0,
          };
        }

        const vertical_rms = Math.sqrt(sumSquares / sampleCount);
        const vertical_max = maxAbs;
        const pitch_mean_deg = pitchCount > 0 ? pitchSum / pitchCount : null;

        return {
          mode: 'vehicle',
          vertical_rms,
          vertical_max,
          pitch_mean_deg,
          sensor_samples: sampleCount,
        };
      };

      return { enable, disable, startSession, stopSession, getSummary };
    }

    const sensorTracker = createSensorTracker();

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function setError(text) {
      errorEl.textContent = text || '';
    }

    function updatePointsCount() {
      pointsCountEl.textContent = `記録ポイント数: ${recordedPoints.length}`;
    }

    function resetRecording() {
      recordedPoints = [];
      updatePointsCount();
      if (polyline) {
        map.removeLayer(polyline);
        polyline = null;
      }
    }

    async function toggleSensors(checked) {
      if (checked) {
        const ok = await sensorTracker.enable();
        if (ok) {
          sensorStatusEl.textContent = 'センサー計測中 (車両固定モード)';
        } else {
          sensorToggle.checked = false;
          sensorStatusEl.textContent = 'センサー非対応、または許可が必要です';
        }
      } else {
        sensorTracker.disable();
        sensorStatusEl.textContent = 'センサーOFF（GPSのみ）';
      }
    }

    sensorToggle.addEventListener('change', (e) => {
      toggleSensors(e.target.checked);
    });

    // Initialize sensor status on load
    sensorStatusEl.textContent = 'センサーOFF（GPSのみ）';

    startBtn.onclick = () => {
      resetRecording();
      statusEl.textContent = "GPS記録中...";
      startBtn.disabled = true;
      stopSendBtn.disabled = false;
      sensorTracker.startSession();

      if (!navigator.geolocation) {
        alert("この端末はGPSが使えません");
        setStatus("GPS非対応");
        startBtn.disabled = false;
        stopSendBtn.disabled = true;
        sensorTracker.stopSession();
        return;
      }

      watchId = navigator.geolocation.watchPosition(
        (pos) => {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          const point = { lat, lon, timestamp_ms: Date.now() };
          recordedPoints.push(point);
          updatePointsCount();

          if (!polyline) {
            polyline = L.polyline([[lat, lon]], { color: "blue" }).addTo(map);
          } else {
            polyline.addLatLng([lat, lon]);
          }
        },
        (err) => {
          console.error(err);
          alert("位置情報が取得できません: " + err.message);
        },
        {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 10000,
        }
      );
    };

    stopSendBtn.onclick = async () => {
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }

      sensorTracker.stopSession();

      if (recordedPoints.length < 2) {
        alert("2ポイント以上記録してから送信してください");
        setStatus("記録が少なすぎます");
        startBtn.disabled = false;
        stopSendBtn.disabled = true;
        return;
      }

      setStatus("送信中...");
      try {
        setError('');
        const res = await fetch('/api/collector/submit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            points: recordedPoints,
            sensor_summary: sensorTracker.getSummary(),
            meta: { note: noteEl.value || undefined },
          }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.detail || '送信に失敗しました');
        }
        setStatus(`送信完了。link_id=${data.link_id}, danger_score=${data.danger_score}`);
        alert('送信しました');
        resetRecording();
      } catch (e) {
        console.error(e);
        setStatus("送信エラー");
        setError(e.message);
      }

      startBtn.disabled = false;
      stopSendBtn.disabled = true;
      sensorTracker.stopSession();
    };
  </script>

  <!-- Self-review:
       - /api/collector/submit に GPS ポイントを送信し、road_links に source='gps' で LINESTRING を挿入し、meta から danger_score を付与するようにした。
       - collector.html にブラウザの geolocation API を使った Start/Stop ロガーと、API への送信処理を追加した。

       Testing:
       - ローカルで `uvicorn main:app --reload` を起動。
       - ブラウザで `http://localhost:8000/collector` を開き、屋外 or 擬似位置情報で「記録開始」→少し移動→「記録停止＆送信」を実行。
       - サーバのログで `/api/collector/submit` のリクエストが成功し、レスポンス JSON に `status: ok` と `danger_score` が含まれていることを確認。
       - `/map` を開き、GPS レイヤー（青）の中に、新しいログの LINESTRING が描画されていることを確認。
  -->
</body>
</html>
